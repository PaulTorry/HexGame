<!DOCTYPE html>
<html>
<head>
  <title>Hex Lib test</title>
  <style>
  body {background-color: black}
  </style>
  <meta charset="UTF-8"/>
  <link rel="stylesheet" href="" type="text/css"/>
  <script>
  "use strict"

  let screenOffset = {x:400,y:400};
  let hexSizeNEW = 55
  let hexes = findHexWithin(3);
  let hexObjects = setupHexes(hexes);

  let selected = {hex : null,    state:"1"};

  function findHexWithin(n){
    let list = []
    for(let i = -n; i<=n; i++){
      for(let j = Math.max(-n, -n-i); j <=Math.min(n, n-i); j++){
        list.push(axialToHex(i, j));
        //      console.log("n: " + n + " i: " + i + " j: " + j);
      }
    }
    return list;
  }

  function setupHexes(hexArray){
    let hexesObj = {};
    for(let i=0; i<hexArray.length; i++){
      let buildingHex = {hex: hexArray[i], objects: {terain:null, owner:1, ship:{type:"basic"}}};
      if(Math.random()>0.5){buildingHex.terain = "gas"};
      hexesObj[""+ hexArray[i].p + "," + hexArray[i].q] = buildingHex;
    }
          console.log("hexesObj: " + hexesObj.toString() + "/n");
    return hexesObj;
  }

  function Vec(x, y){     return {x:x, y:y};   }
  // function divideVec(a, b){     return {x: (b.x != 0 ? a.x/b.x : 0),  y: (b.y != 0 ? a.y/b.y : 0)}      }
  function addVec(a, b){     return {x: a.x + b.x, y: a.y + b.y};   }
  function scaleVec(a, m){     return {x: a.x * m, y: a.y * m};   }
  function dotProd(a, b){     return  a.x * b.x + a.y * b.y;   }


  function Hex(p,q,r){     return {p:p, q:q, r:r};   }
  function Axial(p, q){     return {p:p, q:q}   }
  function hexToAxial(p, q, r){     return {p:p, q:q}   }
  function axialToHex(p, q){     return {p:p, q:q, r: -p-q}   }

  function hexDistance(a, b){  return (Math.abs(a.p - b.p) + Math.abs(a.q - b.q) + Math.abs(a.r - b.r)) / 2        }

  function getRealXYfromScreenXY(a){return addVec(a,scaleVec(screenOffset,-1))}
  function getScreenXYfromRealXY(a){return addVec(a,screenOffset)}

  function getXYfromHex(hexCoord){
    let hexCentre = addVec(scaleVec(hexVec.p, hexCoord.p), scaleVec(hexVec.q, hexCoord.q))
    hexCentre = addVec(hexCentre, scaleVec(hexVec.r, hexCoord.r))
    hexCentre = scaleVec(hexCentre, hexSizeNEW)
    return hexCentre
  }

  function getHexFromXY(xyScaled){
    let {p, q, r} = invHexVec;
    let xy = scaleVec(xyScaled, 1/hexSizeNEW);
    return {p:dotProd(xy,p), q:dotProd(xy,q), r:dotProd(xy,r)}
  }

  const hexVec = {p: Vec(1,0),   q: Vec((-1/2), Math.sqrt(3)/2),  r: Vec((-1/2), -Math.sqrt(3)/2) }
  const invHexVec = {p: Vec(2/(3),0),   q: Vec((-2/6), Math.sqrt(3)/3),  r: Vec((-2/6), -Math.sqrt(3)/3) }

  const hexAxisList =   [{p:1, q:0, r:0}, {p:0, q:0, r:-1}, {p:0, q:1, r:0}, {p:-1, q:0, r:0},  {p:0, q:0, r:1}, {p:0, q:-1, r:0}]
  const hexNeighbours = [{p:1, q:0, r:-1}, {p:0, q:-1, r:1}, {p:-1, q:0, r:1}, {p:-1, q:1, r:0},  {p:0, q:1, r:-1}, {p:1, q:-1, r:0}]

  function hex_round(h){
    let qi = Math.round(h.q);
    let ri = Math.round(h.r);
    let pi = Math.round(h.p);
    let q_diff = Math.abs(qi - h.q);
    let r_diff = Math.abs(ri - h.r);
    let p_diff = Math.abs(pi - h.p);
    if (q_diff > r_diff && q_diff > p_diff)    {           qi = -ri - pi;    }
    else  if (r_diff > p_diff)                 {           ri = -qi - pi;        }
    else                                    {            pi = -qi - ri;        }
    return Hex(pi, qi, ri);
  }


  //  UI and Draw

  function doo(event){

    let clickHex = hex_round(getHexFromXY(getRealXYfromScreenXY({x: event.offsetX, y:event.offsetY})))
  //  console.log(clickHex + "  " + clickHex.p);
    if(hexDistance(clickHex, Hex(0,0,0))<6){ selected.hex = clickHex};
    drawScreen();
  }

  function drawScreen(){
    let line = [];
    //  console.log(hexes);    console.log(hexObjects);
    for(let ho in hexObjects){
      if(hexObjects.hasOwnProperty(ho)){
        //      console.log("hexObjects[ho]" + ho);        console.log(hexObjects[ho]);        console.log(hexObjects[ho].hex, hexSize, offset);
        let colour = "white";
        line.push(drawHex(getXYfromHex(hexObjects[ho].hex), 2 , colour));
        // line.push(drawHexFromObject(hexObjects[ho]));
      }
    }
    for(let ho in hexObjects){
      if(hexObjects.hasOwnProperty(ho) && hexObjects[ho].terain == "gas"){
        //      console.log("hexObjects[ho]" + ho);        console.log(hexObjects[ho]);        console.log(hexObjects[ho].hex, hexSize, offset);
        line.push(drawHex(getXYfromHex(hexObjects[ho].hex), 2 , "white", "darkslateblue"));
        // line.push(drawHexFromObject(hexObjects[ho]));
      }
    }


  //  console.log(selected.hex);
    if(selected.hex){line.push(drawHex(  getXYfromHex(selected.hex), 4 , "red"))};
    document.querySelector("svg").innerHTML = document.querySelector("svg").innerHTML = line;
  }

    function coord_as_string(a){ return "" + a.x  + "," + a.y  + " "; }

  function drawHex( center, stroke, colour, fill="none") {
    let drawstring ="";
    let positions = "";
    for(let i=0; i<hexAxisList.length; i++){
      positions = positions.concat(coord_as_string(getScreenXYfromRealXY(addVec(getXYfromHex( hexAxisList[i]),center ))));
    }
    drawstring = drawstring + "<polygon points= '" + positions + "' stroke='" + colour + "' stroke-width='" + stroke + "' fill='" + fill + "'Â />" ;

    return drawstring;
  }



  </script>


</head>
<body>

  <svg width="800" height="800" style="position: absolute; left='400px'; right='400px' ">  </svg>

</body>
<script>
document.body.addEventListener("click", doo) ;
drawScreen();
</script>

</html>
